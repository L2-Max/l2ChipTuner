#include "l2TextTreeDrv.h"
#include "l2TextTreeCategorySerializer.h"

#include <l2TextTreeParser.tab.hh>
#include <l2RegistryDriverException.h>
#include <l2Variant.h>
#include <l2Trace.h>
#include <l2CategoryKeyParser.h>
#include <l2File.h>
#include <l2MutexLocker.h>
#include <l2Config.h>

namespace l2max
{
   namespace Registry
   {
      namespace Driver
      {
         HInterface CreateInstance()
         {
            TRACE_FUN( Routine, "CreateInstance" );

            return *new CTreeImpl();
         }

         CTreeImpl::CTreeImpl()
         {
            TRACE_FUN( Routine, "CTreeImpl::CTreeImpl" );

            _registryDriverInfo._name = "TextTree";
            _registryDriverInfo._description = "Group settings into tree";
            _registryDriverInfo._version = config::g_version;
            _registryDriverInfo._fileName = "l2maxRegTreeDrv";
         }

         CTreeImpl::~CTreeImpl()
         {
            TRACE_FUN( Routine, "CTreeImpl::~CTreeImpl" );
         }

         bool CTreeImpl::Close()
         {
            TRACE_FUN( Routine, "CTreeImpl::Close" );

            if( !isModified() )
            {
               synchronization().terminate();
            }
            
            WaitForDriverStop();
            
            CMutexLocker locker( synchronization().mutex() );

            bool ret( false );
            
            if( !( ret = !isModified() ) )
            {
               CFile theFile( file() );
               if( !hasError() && theFile.open( CFile::omWriteOnly | CFile::omTruncate ) )
               {
                  std::string buf;
   
                  buf = "/*********************************************************" + CBaseSerializer::cr() +
                        " * The file was generated by l2Registry driver" + CBaseSerializer::cr() +
                        " * Name: " + _registryDriverInfo._name + CBaseSerializer::cr() +
                        " * Description: " + _registryDriverInfo._description + CBaseSerializer::cr() +
                        " * Version: " + _registryDriverInfo._version + CBaseSerializer::cr() +
                        " *********************************************************/" + CBaseSerializer::cr();
   
                  buf += CTextTreeCategorySerializer( category()->members(), 0 ).serialized();
   
                  ret = theFile.write( buf.c_str(), buf.size() ) == buf.size();
               }
            }
            
            if( ret )
            {
               _isModified = false;
            }

            return ret;
         }

         const SInfo* CTreeImpl::driverInfo()const
         {
            TRACE_FUN( Frequently, "CTreeImpl::getDriverInfo" );

            return &_registryDriverInfo;
         }

         EType CTreeImpl::type()const
         {
            return tTextTree;
         }

         void CTreeImpl::parse()
         {
            TRACE_FUN( Routine, "CTreeImpl::parse" );
            
            CLexScaner scaner( &stream() );
            CCategoryParserDriver driver( file(),
                                          scaner,
                                          category(),
                                          synchronization(),
                                          errorRepository() );

            parser theParser( driver );
            theParser.parse();
         }
      }
   }
}
